<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="这是一个采用Enitas框架，用unity制作的roguelike类2D游戏，旨在学习roguelike类游戏制作开发。"><title>UniRx 学习 | DungeonsGame</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="../../../../css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="../../../../favicon.ico"><link rel="apple-touch-icon" href="../../../../apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="../../../../apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">UniRx 学习</h1><a id="logo" href="../../../../.">DungeonsGame</a><p class="description">记录制作的roguelike2D游戏过程。</p></div><div id="nav-menu"><a href="../../../../." class="current"><i class="fa fa-home"> 首页</i></a><a href="../../../../archives/"><i class="fa fa-archive"> 归档</i></a><a href="../../../../about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">UniRx 学习</h1><div class="post-meta">Nov 6, 2016<span> | </span><span class="category"><a href="../../../../categories/程序/">程序</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><h2 id="创建操作"><a href="#创建操作" class="headerlink" title="创建操作"></a>创建操作</h2><h3 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h3><p>使用一个函数从头开始创建一个Observable<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/create.c.png" alt=""><br>示例（冷流）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Observable.Create&lt;int&gt;(o =&gt;</div><div class="line">&#123;</div><div class="line">    o.OnNext(1);</div><div class="line">    o.OnNext(2);</div><div class="line">    o.OnCompleted();</div><div class="line">    return Disposable.Create(() =&gt; Debug.Log(&quot;观察者已取消订阅&quot;));</div><div class="line">&#125;).Subscribe(xx =&gt;</div><div class="line">&#123;</div><div class="line">    Debug.Log(xx);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>示例（热流）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class test : MonoBehaviour</div><div class="line">&#123;</div><div class="line">    List&lt;IObserver&lt;int&gt;&gt; _subscribed = new List&lt;IObserver&lt;int&gt;&gt;();</div><div class="line">    IObservable&lt;int&gt; aa;</div><div class="line">    void Start()</div><div class="line">    &#123;</div><div class="line">        CreateHot();</div><div class="line">        aa.Subscribe(xx =&gt; &#123; Debug.Log(xx); &#125;);</div><div class="line">        onNext(5);</div><div class="line">        onNext(4);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void CreateHot()</div><div class="line">    &#123;</div><div class="line">        aa=Observable.Create&lt;int&gt;(o =&gt;</div><div class="line">        &#123;</div><div class="line">            _subscribed.Add(o);</div><div class="line">            return Disposable.Create(() =&gt; _subscribed.Remove(o));</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void onNext(int val)</div><div class="line">    &#123;</div><div class="line">        foreach (var o in _subscribed)</div><div class="line">        &#123;</div><div class="line">            o.OnNext(val);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Defer"><a href="#Defer" class="headerlink" title="Defer"></a>Defer</h3><p>直到有观察者订阅时才创建Observable，并且为每个观察者创建一个新的Observable<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/defer.c.png" alt=""><br>Defer操作符会一直等待直到有观察者订阅它，然后它使用Observable工厂方法生成一个Observable。它对每个观察者都这样做，因此尽管每个订阅者都以为自己订阅的是同一个Observable，事实上每个订阅者获取的是它们自己的单独的数据序列。<br>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var random = new System.Random();</div><div class="line">Observable.Defer(() =&gt; Observable.Start(() =&gt; random.Next()))</div><div class="line">    .Delay(TimeSpan.FromMilliseconds(1000))</div><div class="line">    .Repeat()</div><div class="line">    .Subscribe(_=&gt;Debug.Log(_));</div></pre></td></tr></table></figure></p>
<h3 id="Empty-Never-Throw"><a href="#Empty-Never-Throw" class="headerlink" title="Empty/Never/Throw"></a>Empty/Never/Throw</h3><h6 id="Empty"><a href="#Empty" class="headerlink" title="Empty"></a>Empty</h6><p>创建一个不发射任何数据但是正常终止的Observable<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static IObservable&lt;T&gt; Empty&lt;T&gt;()</div><div class="line">&#123;</div><div class="line">  return Observable.Create&lt;T&gt;(o =&gt;</div><div class="line">  &#123;</div><div class="line">    o.OnCompleted();</div><div class="line">    return Disposable.Empty;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h6 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h6><p>创建一个不发射数据也不终止的Observable<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static IObservable&lt;T&gt; Never&lt;T&gt;()</div><div class="line">&#123;</div><div class="line">  return Observable.Create&lt;T&gt;(o =&gt;</div><div class="line">  &#123;</div><div class="line">    return Disposable.Empty;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h6 id="Throw"><a href="#Throw" class="headerlink" title="Throw"></a>Throw</h6><p>创建一个不发射数据以一个错误终止的Observable<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static IObservable&lt;T&gt; Throws&lt;T&gt;(Exception exception)</div><div class="line">&#123;</div><div class="line">  return Observable.Create&lt;T&gt;(o =&gt;</div><div class="line">  &#123;</div><div class="line">    o.OnError(exception);</div><div class="line">    return Disposable.Empty;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这三个操作符生成的Observable行为非常特殊和受限。测试的时候很有用，有时候也用于结合其它的Observables，或者作为其它需要Observable的操作符的参数。</p>
<h3 id="From"><a href="#From" class="headerlink" title="From"></a>From</h3><p>将其它种类的对象和数据类型转换为Observable<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/from.c.png" alt=""><br>当你使用Observable时，如果你要处理的数据都可以转换成展现为Observables，而不是需要混合使用Observables和其它类型的数据，会非常方便。这让你在数据流的整个生命周期中，可以使用一组统一的操作符来管理它们。</p>
<h6 id="FromCoroutine"><a href="#FromCoroutine" class="headerlink" title="FromCoroutine"></a>FromCoroutine</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class test : MonoBehaviour</div><div class="line">&#123;</div><div class="line">    void Start()</div><div class="line">    &#123;</div><div class="line">        var cancel = Observable.FromCoroutine(AsyncA)</div><div class="line">            .SelectMany(AsyncB)</div><div class="line">            .Subscribe();</div><div class="line">        cancel.Dispose();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    IEnumerator AsyncA()</div><div class="line">    &#123;</div><div class="line">        Debug.Log(&quot;a start&quot;);</div><div class="line">        yield return new WaitForSeconds(1);</div><div class="line">        Debug.Log(&quot;a end&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    IEnumerator AsyncB()</div><div class="line">    &#123;</div><div class="line">        Debug.Log(&quot;b start&quot;);</div><div class="line">        yield return new WaitForEndOfFrame();</div><div class="line">        Debug.Log(&quot;b end&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="FromAsyncPattern"><a href="#FromAsyncPattern" class="headerlink" title="FromAsyncPattern"></a>FromAsyncPattern</h6><h6 id="FromCoroutineValue"><a href="#FromCoroutineValue" class="headerlink" title="FromCoroutineValue"></a>FromCoroutineValue</h6><h6 id="FromEventPattern"><a href="#FromEventPattern" class="headerlink" title="FromEventPattern"></a>FromEventPattern</h6><h6 id="FromMicroCoroutine"><a href="#FromMicroCoroutine" class="headerlink" title="FromMicroCoroutine"></a>FromMicroCoroutine</h6><h6 id="FromEvent"><a href="#FromEvent" class="headerlink" title="FromEvent"></a>FromEvent</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class test : MonoBehaviour</div><div class="line">&#123;</div><div class="line">    void Start()</div><div class="line">    &#123;</div><div class="line">        LogCallbackAsObservable()</div><div class="line">            .Where(x =&gt; x.LogType == LogType.Warning)</div><div class="line">            .Subscribe();</div><div class="line">        LogCallbackAsObservable()</div><div class="line">            .Where(x =&gt; x.LogType == LogType.Error)</div><div class="line">            .Subscribe();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static IObservable&lt;LogCallback&gt; LogCallbackAsObservable()</div><div class="line">    &#123;</div><div class="line">        return Observable.FromEvent&lt;Application.LogCallback, LogCallback&gt;(</div><div class="line">            h =&gt; (condition, stackTrace, type) =&gt; h(new LogCallback &#123; Condition = condition, StackTrace = stackTrace, LogType = type &#125;),</div><div class="line">            h =&gt; Application.logMessageReceived += h, h =&gt; Application.logMessageReceived -= h);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public class LogCallback</div><div class="line">    &#123;</div><div class="line">        public string Condition;</div><div class="line">        public string StackTrace;</div><div class="line">        public UnityEngine.LogType LogType;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Interval"><a href="#Interval" class="headerlink" title="Interval"></a>Interval</h3><p>创建一个按固定时间间隔发射整数序列的Observable<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/interval.c.png" alt=""><br>Interval操作符返回一个Observable，它按固定的时间间隔发射一个无限递增的整数序列。<br>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    Observable.Interval(TimeSpan.FromMilliseconds(1000))</div><div class="line">        .Subscribe(_ =&gt; &#123; Debug.Log(_); &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Return"><a href="#Return" class="headerlink" title="Return"></a>Return</h3><p>创建一个发射指定值的Observable<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/just.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static IObservable&lt;T&gt; Return&lt;T&gt;(T value)</div><div class="line">&#123;</div><div class="line">  return Observable.Create&lt;T&gt;(o =&gt;</div><div class="line">  &#123;</div><div class="line">    o.OnNext(value);</div><div class="line">    o.OnCompleted();</div><div class="line">    return Disposable.Empty;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Just将单个数据转换为发射那个数据的Observable。</p>
<p>return类似于From，但是From会将数组或Iterable的素具取出然后逐个发射，而return只是简单的原样发射，将数组或Iterable当做单个数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    var singleValue = Observable.Return&lt;string&gt;(&quot;Value&quot;);</div><div class="line">    singleValue.Subscribe(xx =&gt; Debug.Log(xx));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p>创建一个发射特定整数序列的Observable<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/range.png" alt=""><br>Range操作符发射一个范围内的有序整数序列，你可以指定范围的起始和长度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    var singleValue = Observable.Range(10, 15);</div><div class="line">    singleValue.Subscribe(xx =&gt; Debug.Log(xx));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Repeat"><a href="#Repeat" class="headerlink" title="Repeat"></a>Repeat</h3><p>创建一个发射特定数据重复多次的Observable<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/repeat.c.png" alt=""><br>Repeat重复地发射数据。某些实现允许你重复的发射某个数据序列，还有一些允许你限制重复的次数。<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/repeat.o.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    Observable.Repeat(&quot;aa&quot;,3)</div><div class="line">        .Subscribe(xx =&gt; Debug.Log(xx));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h3><p>返回一个Observable，它发射一个类似于函数声明的值<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/start.png" alt=""><br>注意：这个函数只会被执行一次，即使多个观察者订阅这个返回的Observable。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    Observable.Start(() =&gt;</div><div class="line">    &#123;</div><div class="line">        Debug.Log(&quot;lalala&quot;);</div><div class="line">    &#125;).Subscribe();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><p>创建一个Observable，它在一个给定的延迟后发射一个特殊的值。<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/timer.png" alt=""><br>Timer操作符创建一个在给定的时间段之后返回一个特殊值的Observable。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    Observable.Timer(TimeSpan.FromSeconds(3))</div><div class="line">        .Subscribe(_=&gt; Debug.Log(_));</div><div class="line">&#125;</div><div class="line"></div><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    Observable.Timer(TimeSpan.Zero, TimeSpan.FromSeconds(3))</div><div class="line">        .Subscribe(_=&gt; Debug.Log(_));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="变换操作"><a href="#变换操作" class="headerlink" title="变换操作"></a>变换操作</h2><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>定期收集Observable的数据放进一个数据包裹，然后发射这些数据包裹，而不是一次发射一个值。<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/buffer.png" alt=""><br>Buffer操作符将一个Observable变换为另一个，原来的Observable正常发射数据，变换产生的Observable发射这些数据的缓存集合。Buffer操作符在很多语言特定的实现中有很多种变体，它们在如何缓存这个问题上存在区别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    Observable.Range(0, 10)</div><div class="line">        .Buffer(3)</div><div class="line">        .Subscribe(xx =&gt; Debug.Log(xx[0]));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="SelectMany"><a href="#SelectMany" class="headerlink" title="SelectMany"></a>SelectMany</h3><p>SelectMany将一个发射数据的Observable变换为多个Observables，然后将它们发射的数据合并后放进一个单独的Observable<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/flatMap.png" alt=""><br>SelectMany操作符使用一个指定的函数对原始Observable发射的每一项数据执行变换操作，这个函数返回一个本身也发射数据的Observable，然后SelectMany合并这些Observables发射的数据，最后将合并后的结果当做它自己的数据序列发射。<br>这个方法是很有用的，例如，当你有一个这样的Observable：它发射一个数据序列，这些数据本身包含Observable成员或者可以变换为Observable，因此你可以创建一个新的Observable发射这些次级Observable发射的数据的完整集合。</p>
<p>注意：SelectMany对这些Observables发射的数据做的是合并(merge)操作，因此它们可能是交错的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    Observable.Return(3)</div><div class="line">        .SelectMany(i =&gt; Observable.Range(1, i))</div><div class="line">        .Subscribe(xx =&gt;</div><div class="line">        &#123;</div><div class="line">            Debug.Log(&quot;SelectMany:&quot; + xx);</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class test : MonoBehaviour</div><div class="line">&#123;</div><div class="line">    void Start()</div><div class="line">    &#123;</div><div class="line">        Observable.Interval(TimeSpan.FromSeconds(1))</div><div class="line">            .Select(i =&gt; i + 1)</div><div class="line">            .Take(3)</div><div class="line">            .SelectMany(GetSubValues(3))</div><div class="line">            .Subscribe(xx =&gt;</div><div class="line">            &#123;</div><div class="line">                Debug.Log(&quot;SelectMany:&quot; + xx);</div><div class="line">            &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private IObservable&lt;long&gt; GetSubValues(long offset)</div><div class="line">    &#123;</div><div class="line">        return Observable.Timer(TimeSpan.Zero, TimeSpan.FromSeconds(4))</div><div class="line">        .Select(x =&gt; (offset * 10) + x)</div><div class="line">        .Take(3);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="GroupBy"><a href="#GroupBy" class="headerlink" title="GroupBy"></a>GroupBy</h3><p>将一个Observable分拆为一些Observables集合，它们中的每一个发射原始Observable的一个子序列<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/groupBy.c.png" alt=""><br>GroupBy操作符将原始Observable分拆为一些Observables集合，它们中的每一个发射原始Observable数据序列的一个子序列。哪个数据项由哪一个Observable发射是由一个函数判定的，这个函数给每一项指定一个Key，Key相同的数据会被同一个Observable发射。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    var source = Observable.Interval(TimeSpan.FromSeconds(0.1)).Take(10);</div><div class="line">    var group = source.GroupBy(i =&gt; i%3);</div><div class="line">    group.Subscribe(</div><div class="line">        xx =&gt; Debug.Log(xx.Key));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Cast"><a href="#Cast" class="headerlink" title="Cast"></a>Cast</h3><p>cast操作符将原始Observable发射的每一项数据都强制转换为一个指定的类型，然后再发射数据;<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/cast.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    Observable.Return(0)</div><div class="line">        .Cast(&quot;s&quot;)</div><div class="line">        .Subscribe();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应的有OfType或者通过.Select(i=&gt;(int)i)转换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    var ss = new object[] &#123;1, &quot;s&quot;, 0.2f, 3, &quot;g&quot;&#125;;</div><div class="line">    ss.ToObservable()</div><div class="line">        .OfType(2)</div><div class="line">        .Subscribe(xx =&gt;</div><div class="line">        &#123;</div><div class="line">            Debug.Log(xx);</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Aggregate"><a href="#Aggregate" class="headerlink" title="Aggregate"></a>Aggregate</h3><p>聚合方法允许您对序列应用累加器函数<br>对于基本过载，您需要提供一个函数，该函数获取累加值的当前状态和序列推送的值。该函数的结果是新的累加值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    Observable.Range(0, 8)</div><div class="line">        .Aggregate(0,(acc,currentValue)=&gt;acc+5)</div><div class="line">        .Subscribe(xx =&gt;</div><div class="line">        &#123;</div><div class="line">            Debug.Log(xx);</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class test : MonoBehaviour</div><div class="line">&#123;</div><div class="line">    void Start()</div><div class="line">    &#123;</div><div class="line">        Observable.Range(0, 8)</div><div class="line">            .MyMax()</div><div class="line">            .Subscribe(xx =&gt;</div><div class="line">            &#123;</div><div class="line">                Debug.Log(xx);</div><div class="line">            &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public static class tt</div><div class="line">&#123;</div><div class="line">    public static IObservable&lt;T&gt; MyMax&lt;T&gt;(this IObservable&lt;T&gt; source)</div><div class="line">    &#123;</div><div class="line">        var comparer = Comparer&lt;T&gt;.Default;</div><div class="line">        Func&lt;T, T, T&gt; max =</div><div class="line">        (x, y) =&gt;</div><div class="line">        &#123;</div><div class="line">            if (comparer.Compare(x, y) &lt; 0)</div><div class="line">            &#123;</div><div class="line">                return y;</div><div class="line">            &#125;</div><div class="line">            return x;</div><div class="line">        &#125;;</div><div class="line">        return source.Aggregate(max);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a>Scan</h3><p>连续地对数据序列的每一项应用一个函数，然后连续发射结果<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/scan.c.png" alt=""><br>Scan操作符对原始Observable发射的第一项数据应用一个函数，然后将那个函数的结果作为自己的第一项数据发射。它将函数的结果同第二项数据一起填充给这个函数来产生它自己的第二项数据。它持续进行这个过程来产生剩余的数据序列。这个操作符在某些情况下被叫做accumulator。<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/scan.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    Observable.Range(0, 5)</div><div class="line">        .Scan((x, y) =&gt; x + y)</div><div class="line">        .Subscribe(xx =&gt;</div><div class="line">        &#123;</div><div class="line">            Debug.Log(xx);</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="过滤操作"><a href="#过滤操作" class="headerlink" title="过滤操作"></a>过滤操作</h2><h3 id="Throttle"><a href="#Throttle" class="headerlink" title="Throttle"></a>Throttle</h3><p>仅在过了一段指定的时间还没发射数据时才发射一个数据<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/debounce.c.png" alt=""><br>Debounce操作符会过滤掉发射速率过快的数据项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    var clickStream = Observable.EveryUpdate()</div><div class="line">        .Where(_ =&gt; Input.GetMouseButtonDown(0));</div><div class="line">    clickStream.Buffer(clickStream.Throttle(TimeSpan.FromMilliseconds(250)))</div><div class="line">        .Where(xs =&gt; xs.Count &gt;= 2)</div><div class="line">        .Subscribe(xs =&gt; Debug.Log(&quot;click count:&quot; + xs.Count));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Distinct"><a href="#Distinct" class="headerlink" title="Distinct"></a>Distinct</h3><p>抑制（过滤掉）重复的数据项<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/distinct.c.png" alt=""><br>Distinct的过滤规则是：只允许还没有发射过的数据项通过。</p>
<p>在某些实现中，有一些变体允许你调整判定两个数据不同(distinct)的标准。还有一些实现只比较一项数据和它的直接前驱，因此只会从序列中过滤掉连续重复的数据。<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/distinct.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    var ss = new int[] &#123;1, 2, 5, 5, 6, 8, 9, 6&#125;;</div><div class="line">    ss.ToObservable()</div><div class="line">        .Distinct()</div><div class="line">        .Subscribe(xx =&gt;</div><div class="line">        &#123;</div><div class="line">            Debug.Log(xx);</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="DistinctUntilChanged"><a href="#DistinctUntilChanged" class="headerlink" title="DistinctUntilChanged"></a>DistinctUntilChanged</h5><p><img src="http://uprogrammer.cn/rxjava_cn/images/operators/distinctUntilChanged.png" alt=""><br>只判定一个数据和它的直接前驱是否是不同的。</p>
<h5 id="DistinctUntilChanged-func"><a href="#DistinctUntilChanged-func" class="headerlink" title="DistinctUntilChanged(func)"></a>DistinctUntilChanged(func)</h5><p><img src="http://uprogrammer.cn/rxjava_cn/images/operators/distinctUntilChanged.key.png" alt=""><br>根据一个函数产生的Key判定两个相邻的数据项是不是不同的。</p>
<h3 id="Where"><a href="#Where" class="headerlink" title="Where"></a>Where</h3><p>只发射通过了谓词测试的数据项<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/filter.c.png" alt=""><br>Where操作符使用你指定的一个谓词函数测试数据项，只有通过测试的数据才会被发射。<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/filter.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    Observable.Range(1, 10)</div><div class="line">        .Where(x =&gt; x &gt;= 5)</div><div class="line">        .Subscribe(xx =&gt;</div><div class="line">        &#123;</div><div class="line">            Debug.Log(xx);</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="First"><a href="#First" class="headerlink" title="First"></a>First</h3><p>只发射第一项（或者满足某个条件的第一项）数据<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/first.c.png" alt=""><br>如果你只对Observable发射的第一项数据，或者满足某个条件的第一项数据感兴趣，你可以使用First操作符。</p>
<p>在某些实现中，First没有实现为一个返回Observable的过滤操作符，而是实现为一个在当时就发射原始Observable指定数据项的阻塞函数。在这些实现中，如果你想要的是一个过滤操作符，最好使用Take(1)<br>在一些实现中还有一个Single操作符。它的行为与First类似，但为了确保只发射单个值，它会等待原始Observable终止（否则，不是发射那个值，而是以一个错误通知终止）。你可以使用它从原始Observable获取第一项数据，而且也确保只发射一项数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    Observable.Range(1, 10)</div><div class="line">        .Where(x =&gt; x &gt;= 5)</div><div class="line">        .First()</div><div class="line">        .Subscribe(xx =&gt;</div><div class="line">        &#123;</div><div class="line">            Debug.Log(xx);</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="FirstOrDefault"><a href="#FirstOrDefault" class="headerlink" title="FirstOrDefault"></a>FirstOrDefault</h5><p>firstOrDefault与first类似，但是在Observagle没有发射任何数据时发射一个你在参数中指定的默认值。<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/firstOrDefault.png" alt=""></p>
<h5 id="single"><a href="#single" class="headerlink" title="single"></a>single</h5><p>single操作符也与first类似，但是如果原始Observable在完成之前不是正好发射一次数据，它会抛出一个NoSuchElementException。<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/single.png" alt=""></p>
<h5 id="singleOrDefault"><a href="#singleOrDefault" class="headerlink" title="singleOrDefault"></a>singleOrDefault</h5><p>和firstOrDefault类似，但是如果原始Observable发射超过一个的数据，会以错误通知终止。<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/singleOrDefault.png" alt=""></p>
<h3 id="IgnoreElements"><a href="#IgnoreElements" class="headerlink" title="IgnoreElements"></a>IgnoreElements</h3><p>不发射任何数据，只发射Observable的终止通知<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/ignoreElements.c.png" alt=""><br>IgnoreElements操作符抑制原始Observable发射的所有数据，只允许它的终止通知（onError或onCompleted）通过。</p>
<p>如果你不关心一个Observable发射的数据，但是希望在它完成时或遇到错误终止时收到通知，你可以对Observable使用ignoreElements操作符，它会确保永远不会调用观察者的onNext()方法。</p>
<h3 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h3><p>只发射最后一项（或者满足某个条件的最后一项）数据<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/last.c.png" alt=""><br>如果你只对Observable发射的最后一项数据，或者满足某个条件的最后一项数据感兴趣，你可以使用Last操作符。</p>
<p>在某些实现中，Last没有实现为一个返回Observable的过滤操作符，而是实现为一个在当时就发射原始Observable指定数据项的阻塞函数。在这些实现中，如果你想要的是一个过滤操作符，最好使用TakeLast(1)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    Observable.Range(1, 10)</div><div class="line">        .Where(x =&gt; x &gt;= 5)</div><div class="line">        .Last()</div><div class="line">        .Subscribe(xx =&gt;</div><div class="line">        &#123;</div><div class="line">            Debug.Log(xx);</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="LastOrDefault"><a href="#LastOrDefault" class="headerlink" title="LastOrDefault"></a>LastOrDefault</h5><p>lastOrDefault与last类似，不同的是，如果原始Observable没有发射任何值，它发射你指定的默认值。<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/lastOrDefault.png" alt=""></p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><p>定期发射Observable最近发射的数据项<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/sample.c.png" alt=""><br>Sample操作符定时查看一个Observable，然后发射自上次采样以来它最近发射的数据。</p>
<p>在某些实现中，有一个ThrottleFirst操作符的功能类似，但不是发射采样期间的最近的数据，而是发射在那段时间内的第一项数据。<br>注意：如果自上次采样以来，原始Observable没有发射任何数据，这个操作返回的Observable在那段时间内也不会发射任何数据。<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/sample.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    Observable.Timer(TimeSpan.FromSeconds(1))</div><div class="line">        .Sample(TimeSpan.FromSeconds(3))</div><div class="line">        .Subscribe(xx =&gt;</div><div class="line">        &#123;</div><div class="line">            Debug.Log(xx);</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    Observable.Range(0,5)</div><div class="line">        .Sample(Observable.Range(1,2))</div><div class="line">        .Subscribe(xx =&gt;</div><div class="line">        &#123;</div><div class="line">            Debug.Log(xx);</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="SampleFrame"><a href="#SampleFrame" class="headerlink" title="SampleFrame"></a>SampleFrame</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    var cube = GameObject.CreatePrimitive(PrimitiveType.Cube);</div><div class="line"></div><div class="line">    cube.AddComponent&lt;ObservableUpdateTrigger&gt;()</div><div class="line">        .UpdateAsObservable()</div><div class="line">        .SampleFrame(30)</div><div class="line">        .Subscribe(x =&gt; Debug.Log(&quot;cube&quot;), () =&gt; Debug.Log(&quot;destroy&quot;));</div><div class="line"></div><div class="line">    GameObject.Destroy(cube, 3f);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Skip"><a href="#Skip" class="headerlink" title="Skip"></a>Skip</h3><p>抑制Observable发射的前N项数据<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/skip.c.png" alt=""><br>使用Skip操作符，你可以忽略Observable’发射的前N项数据，只保留之后的数据。<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/skip.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    Observable.Range(0,5)</div><div class="line">        .Skip(3)</div><div class="line">        .Subscribe(xx =&gt;</div><div class="line">        &#123;</div><div class="line">            Debug.Log(xx);</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Take"><a href="#Take" class="headerlink" title="Take"></a>Take</h3><p>只发射前面的N项数据<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/take.c.png" alt=""><br>使用Take操作符让你可以修改Observable的行为，只返回前面的N项数据，然后发射完成通知，忽略剩余的数据。<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/take.png" alt=""></p>
<h5 id="TakeLast"><a href="#TakeLast" class="headerlink" title="TakeLast"></a>TakeLast</h5><p>发射Observable发射的最后N项数据<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/takeLast.c.png" alt=""><br>使用TakeLast操作符修改原始Observable，你可以只发射Observable’发射的后N项数据，忽略前面的数据。<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/takeLast.n.png" alt=""><br>使用takeLast操作符，你可以只发射原始Observable发射的后N项数据，忽略之前的数据。注意：这会延迟原始Observable发射的任何数据项，直到它全部完成。</p>
<p>takeLast的这个变体默认不在任何特定的调度器上执行。</p>
<h2 id="结合操作"><a href="#结合操作" class="headerlink" title="结合操作"></a>结合操作</h2><h3 id="CombineLatest"><a href="#CombineLatest" class="headerlink" title="CombineLatest"></a>CombineLatest</h3><p>当两个Observables中的任何一个发射了数据时，使用一个函数结合每个Observable发射的最近数据项，并且基于这个函数的结果发射数据。<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/combineLatest.c.png" alt=""></p>
<p>CombineLatest操作符行为类似于zip，但是只有当原始的Observable中的每一个都发射了一条数据时zip才发射数据。CombineLatest则在原始的Observable中任意一个发射了数据时发射一条数据。当原始Observables的任何一个发射了一条数据时，CombineLatest使用一个函数结合它们最近发射的数据，然后发射这个函数的返回值。<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/combineLatest.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    var GiveName = new ReactiveProperty&lt;string&gt;(&quot;bob&quot;);</div><div class="line">    var FamilyName = new ReactiveProperty&lt;string&gt;(&quot;rock&quot;);</div><div class="line">    var fullName = GiveName.CombineLatest(FamilyName, (x, y) =&gt; x + &quot; &quot; + y)</div><div class="line">        .ToReactiveProperty();</div><div class="line">    Debug.Log(fullName);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="WhenAll"><a href="#WhenAll" class="headerlink" title="WhenAll"></a>WhenAll</h3><p>将两个或多个Observable发射的数据集合并到一起,操作符组合的行为类似于zip，但是它们使用一个中间数据结构。接受两个或多个Observable，一次一个将它们的发射物合并到Pattern对象，然后操作那个Pattern对象，变换为一个Plan。随后将这些Plan变换为Observable的发射物。<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/and_then_when.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    var heavyMethod = Observable.Start(() =&gt; &#123; return 10; &#125;);</div><div class="line">    var heavyMethod2 = Observable.Start(() =&gt; &#123; return 20; &#125;);</div><div class="line">    Observable.WhenAll(heavyMethod, heavyMethod2)</div><div class="line">        .Subscribe(xs =&gt;</div><div class="line">        &#123;</div><div class="line">            Debug.Log(xs[0] + &quot;:&quot; + xs[1]);</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h3><p>合并多个Observables的发射物<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/merge.c.png" alt=""><br>使用Merge操作符你可以将多个Observables的输出合并，就好像它们是一个单个的Observable一样。</p>
<p>Merge可能会让合并的Observables发射的数据交错（有一个类似的操作符Concat不会让数据交错，它会按顺序一个接着一个发射多个Observables的发射物）。</p>
<p>正如图例上展示的，任何一个原始Observable的onError通知会被立即传递给观察者，而且会终止合并后的Observable。<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/mergeDelayError.C.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    var s1 = Observable.Return(10);</div><div class="line">    var s2 = Observable.Return(5);</div><div class="line">    var ss = s1.Merge(s2)</div><div class="line">        .Finally(() =&gt;</div><div class="line">        &#123;</div><div class="line">            Debug.Log(&quot;finished!&quot;);</div><div class="line">        &#125;);</div><div class="line">    ss.Subscribe(xx =&gt;</div><div class="line">    &#123;</div><div class="line">        Debug.Log(xx);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public static class Ext</div><div class="line">&#123;</div><div class="line">    public static IObservable&lt;T&gt; MergeWithCompleteOnEither&lt;T&gt;(this IObservable&lt;T&gt; source, IObservable&lt;T&gt; right)</div><div class="line">    &#123;</div><div class="line">        var completed = Observable.Throw&lt;T&gt;(new StreamCompletedException());</div><div class="line"></div><div class="line">        return</div><div class="line">            source.Concat(completed)</div><div class="line">            .Merge(right.Concat(completed))</div><div class="line">            .Catch((StreamCompletedException ex) =&gt; Observable.Empty&lt;T&gt;());</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private sealed class StreamCompletedException : Exception</div><div class="line">    &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="StartWith"><a href="#StartWith" class="headerlink" title="StartWith"></a>StartWith</h3><p>在数据序列的开头插入一条指定的项<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/startWith.c.png" alt=""><br>如果你想要一个Observable在发射数据之前先发射一个指定的数据序列，可以使用StartWith操作符。（如果你想一个Observable发射的数据末尾追加一个数据序列可以使用Concat操作符。）<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/startWith.png" alt=""><br>可接受一个Iterable或者多个Observable作为函数的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    var s1 = Observable.Return(10);</div><div class="line">    var s2 = Observable.Return(5);</div><div class="line">    var ss = s1.Merge(s2)</div><div class="line">        .StartWith(8);</div><div class="line">    ss.Subscribe(xx =&gt;</div><div class="line">    &#123;</div><div class="line">        Debug.Log(xx);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h3><p>将一个发射多个Observables的Observable转换成另一个单独的Observable，后者发射那些Observables最近发射的数据项<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/switch.c.png" alt=""><br>Switch订阅一个发射多个Observables的Observable。它每次观察那些Observables中的一个，Switch返回的这个Observable取消订阅前一个发射数据的Observable，开始发射最近的Observable发射的数据。注意：当原始Observable发射了一个新的Observable时（不是这个新的Observable发射了一条数据时），它将取消订阅之前的那个Observable。这意味着，在后来那个Observable产生之后到它开始发射数据之前的这段时间里，前一个Observable发射的数据将被丢弃（就像图例上的那个黄色圆圈一样）。</p>
<h3 id="Zip"><a href="#Zip" class="headerlink" title="Zip"></a>Zip</h3><p>通过一个函数将多个Observables的发射物结合到一起，基于这个函数的结果为每个结合体发射单个数据项。<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/zip.c.png" alt=""><br>Zip操作符返回一个Obversable，它使用这个函数按顺序结合两个或多个Observables发射的数据项，然后它发射这个函数返回的结果。它按照严格的顺序应用这个函数。它只发射与发射数据项最少的那个Observable一样多的数据。<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/zip.o.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    var stream1 = Observable.Interval(TimeSpan.FromMilliseconds(250)).Take(3);</div><div class="line">    var stream2 = Observable.Interval(TimeSpan.FromMilliseconds(150)).Take(6).Select(i =&gt; Char.ConvertFromUtf32((int)i + 97));</div><div class="line">    stream1</div><div class="line">        .Zip(stream2, (lhs, rhs) =&gt; new &#123;Left = lhs, Right = rhs&#125;)</div><div class="line">        .Subscribe(xx =&gt;</div><div class="line">        &#123;</div><div class="line">            Debug.Log(xx);</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="Catch"><a href="#Catch" class="headerlink" title="Catch"></a>Catch</h3><p>从onError通知中恢复发射数据<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/catch.png" alt=""><br>Catch操作符拦截原始Observable的onError通知，将它替换为其它的数据项或数据序列，让产生的Observable能够正常终止或者根本不终止。</p>
<h3 id="Retry"><a href="#Retry" class="headerlink" title="Retry"></a>Retry</h3><p>如果原始Observable遇到错误，重新订阅它期望它能正常终止<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/retry.C.png" alt=""><br>Retry操作符不会将原始Observable的onError通知传递给观察者，它会订阅这个Observable，再给它一次机会无错误地完成它的数据序列。Retry总是传递onNext通知给观察者，由于重新订阅，可能会造成数据项重复</p>
<h2 id="辅助操作"><a href="#辅助操作" class="headerlink" title="辅助操作"></a>辅助操作</h2><h3 id="Delay"><a href="#Delay" class="headerlink" title="Delay"></a>Delay</h3><p>延迟一段指定的时间再发射来自Observable的发射物<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/delay.c.png" alt=""><br>Delay操作符让原始Observable在发射每项数据之前都暂停一段指定的时间段。效果是Observable发射的数据项在时间上向前整体平移了一个增量。<br>第一种delay接受一个定义时长的参数（包括数量和单位）。每当原始Observable发射一项数据，delay就启动一个定时器，当定时器过了给定的时间段时，delay返回的Observable发射相同的数据项。</p>
<p>注意：delay不会平移onError通知，它会立即将这个通知传递给订阅者，同时丢弃任何待发射的onNext通知。然而它会平移一个onCompleted通知。</p>
<p>delay默认在computation调度器上执行，你可以通过参数指定使用其它的调度器。</p>
<p>另一种delay不实用常数延时参数，它使用一个函数针对原始Observable的每一项数据返回一个Observable，它监视返回的这个Observable，当任何那样的Observable终止时，delay返回的Observable就发射关联的那项数据。</p>
<p>这种delay默认不在任何特定的调度器上执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    Observable.Range(0, 5)</div><div class="line">        .Delay(TimeSpan.FromSeconds(2))</div><div class="line">        .Subscribe(xx =&gt;</div><div class="line">        &#123;</div><div class="line">            Debug.Log(xx);</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Do"><a href="#Do" class="headerlink" title="Do"></a>Do</h3><p>注册一个动作作为原始Observable生命周期事件的一种占位符<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/do.c.png" alt=""><br>你可以注册回调，当Observable的某个事件发生时，Rx会在与Observable链关联的正常通知集合中调用它。Rx实现了多种操作符用于达到这个目的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    var elements = new[] &#123;1, 2, 3&#125;;</div><div class="line">    elements.ToObservable()</div><div class="line">        .Do(e =&gt; Debug.Log(e))</div><div class="line">        .Subscribe();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Materialize-Dematerialize"><a href="#Materialize-Dematerialize" class="headerlink" title="Materialize/Dematerialize"></a>Materialize/Dematerialize</h3><p>Materialize将数据项和事件通知都当做数据项发射，Dematerialize刚好相反。<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/materialize.c.png" alt=""><br>一个合法的有限的Obversable将调用它的观察者的onNext方法零次或多次，然后调用观察者的onCompleted或onError正好一次。Materialize操作符将这一系列调用，包括原来的onNext通知和终止通知onCompleted或onError都转换为一个Observable发射的数据序列。<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/dematerialize.c.png" alt=""><br>Dematerialize操作符是Materialize的逆向过程，它将Materialize转换的结果还原成它原本的形式。</p>
<p>dematerialize反转这个过程，将原始Observable发射的Notification对象还原成Observable的通知。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    var subject = new Subject&lt;int&gt;();</div><div class="line">    var onlyExceptions = subject.Materialize().Where(n =&gt; n.Exception != null).Dematerialize();</div><div class="line">    subject.Subscribe(i =&gt; Debug.LogFormat(&quot;Subscriber 1: &#123;0&#125;&quot;, i),</div><div class="line">                        ex =&gt; Debug.LogFormat(&quot;Subscriber 1 exception: &#123;0&#125;&quot;,ex.Message));</div><div class="line"></div><div class="line">    onlyExceptions.Subscribe(i =&gt; Debug.LogFormat(&quot;Subscriber 2: &#123;0&#125;&quot;, i),</div><div class="line">                                ex =&gt; Debug.LogFormat(&quot;Subscriber 2 exception: &#123;0&#125;&quot;, ex.Message));</div><div class="line"></div><div class="line">    subject.OnNext(123);</div><div class="line">    subject.OnError(new Exception(&quot;Test Exception&quot;));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ObserveOn"><a href="#ObserveOn" class="headerlink" title="ObserveOn"></a>ObserveOn</h3><p>指定一个观察者在哪个调度器上观察这个Observable<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/observeOn.c.png" alt=""><br>很多ReactiveX实现都使用调度器<br>“Scheduler”来管理多线程环境中Observable的转场。你可以使用ObserveOn操作符指定Observable在一个特定的调度器上发送通知给观察者 (调用观察者的onNext, onCompleted, onError方法)。<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/observeOn.e.png" alt=""><br>注意：当遇到一个异常时ObserveOn会立即向前传递这个onError终止通知，它不会等待慢速消费的Observable接受任何之前它已经收到但还没有发射的数据项。这可能意味着onError通知会跳到（并吞掉）原始Observable发射的数据项前面，正如图例上展示的。</p>
<p>SubscribeOn操作符的作用类似，但它是用于指定Observable本身在特定的调度器上执行，它同样会在那个调度器上给观察者发通知。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    var heavyMethod = Observable.Start(() =&gt;</div><div class="line">    &#123;</div><div class="line">        System.Threading.Thread.Sleep(TimeSpan.FromSeconds(1));</div><div class="line">        return 10;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    var heavyMethod2 = Observable.Start(() =&gt;</div><div class="line">    &#123;</div><div class="line">        System.Threading.Thread.Sleep(TimeSpan.FromSeconds(3));</div><div class="line">        return 10;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    Observable.WhenAll(heavyMethod, heavyMethod2)</div><div class="line">        .ObserveOnMainThread() // return to main thread</div><div class="line">        .Subscribe(xs =&gt;</div><div class="line">        &#123;</div><div class="line">            Debug.Log(xs[0] + &quot;:&quot; + xs[1]);</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="SubscribeOn"><a href="#SubscribeOn" class="headerlink" title="SubscribeOn"></a>SubscribeOn</h3><p>指定Observable自身在哪个调度器上执行<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/subscribeOn.c.png" alt=""><br>很多ReactiveX实现都使用调度器 “Scheduler”来管理多线程环境中Observable的转场。你可以使用SubscribeOn操作符指定Observable在一个特定的调度器上运转。</p>
<p>ObserveOn操作符的作用类似，但是功能很有限，它指示Observable在一个指定的调度器上给观察者发通知。</p>
<h3 id="TimeInterval"><a href="#TimeInterval" class="headerlink" title="TimeInterval"></a>TimeInterval</h3><p>将一个发射数据的Observable转换为发射那些数据发射时间间隔的Observable<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/timeInterval.c.png" alt=""><br>TimeInterval操作符拦截原始Observable发射的数据项，替换为发射表示相邻发射物时间间隔的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void Start()</div><div class="line">&#123;</div><div class="line">    Observable.Interval(TimeSpan.FromMilliseconds(750))</div><div class="line">        .TimeInterval()</div><div class="line">        .Do(x =&gt; Debug.Log(x))</div><div class="line">        .Subscribe();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Timeout"><a href="#Timeout" class="headerlink" title="Timeout"></a>Timeout</h3><p>对原始Observable的一个镜像，如果过了一个指定的时长仍没有发射数据，它会发一个错误通知<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/timeout.c.png" alt=""><br>如果原始Observable过了指定的一段时长没有发射任何数据，Timeout操作符会以一个onError通知终止这个Observable。</p>
<h3 id="Timestamp"><a href="#Timestamp" class="headerlink" title="Timestamp"></a>Timestamp</h3><p>给Observable发射的数据项附加一个时间戳<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/timestamp.c.png" alt=""><br>timestamp默认在immediate调度器上执行，但是可以通过参数指定其它的调度器。</p>
<h3 id="Using"><a href="#Using" class="headerlink" title="Using"></a>Using</h3><p>创建一个只在Observable生命周期内存在的一次性资源<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/using.c.png" alt=""><br>Using操作符让你可以指示Observable创建一个只在它的生命周期内存在的资源，当Observable终止时这个资源会被自动释放。<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/using.png" alt=""><br>using操作符接受三个参数：</p>
<p>一个用户创建一次性资源的工厂函数<br>一个用于创建Observable的工厂函数<br>一个用于释放资源的函数<br>当一个观察者订阅using返回的Observable时，using将会使用Observable工厂函数创建观察者要观察的Observable，同时使用资源工厂函数创建一个你想要创建的资源。当观察者取消订阅这个Observable时，或者当观察者终止时（无论是正常终止还是因错误而终止），using使用第三个函数释放它创建的资源。</p>
<p>using默认不在任何特定的调度器上执行。</p>
<h3 id="To"><a href="#To" class="headerlink" title="To"></a>To</h3><p>将Observable转换为另一个对象或数据结构<br><img src="http://uprogrammer.cn/rxjava_cn/images/operators/to.c.png" alt=""></p>
<h5 id="ToArray"><a href="#ToArray" class="headerlink" title="ToArray"></a>ToArray</h5><h5 id="ToAsync"><a href="#ToAsync" class="headerlink" title="ToAsync"></a>ToAsync</h5><h5 id="ToAwaitableEnumerator"><a href="#ToAwaitableEnumerator" class="headerlink" title="ToAwaitableEnumerator"></a>ToAwaitableEnumerator</h5><h5 id="ToList"><a href="#ToList" class="headerlink" title="ToList"></a>ToList</h5><h5 id="ToObservable"><a href="#ToObservable" class="headerlink" title="ToObservable"></a>ToObservable</h5><h5 id="ToYieldInstruction"><a href="#ToYieldInstruction" class="headerlink" title="ToYieldInstruction"></a>ToYieldInstruction</h5></div><div class="tags"><a href="../../../../tags/程序/">程序</a></div><div class="post-nav"><a href="../../07/UniRx-学习-2-存储层次数据/" class="pre">UniRx-学习[2]--存储层次数据</a><a href="../../04/顺利拿到一坑/" class="next">顺利拿到一坑</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://github.com/KuaileY/DungeonsGame"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="../../../../categories/学习/">学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../categories/程序/">程序</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../categories/策划/">策划</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../categories/美术/">美术</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="../../../../tags/程序/" style="font-size: 15px;">程序</a> <a href="../../../../tags/策划/" style="font-size: 15px;">策划</a> <a href="../../../../tags/美术/" style="font-size: 15px;">美术</a> <a href="../../../../tags/git/" style="font-size: 15px;">git</a> <a href="../../../../tags/感悟/" style="font-size: 15px;">感悟</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="../../08/Sqlite4Unity学习/">Sqlite4Unity学习</a></li><li class="post-list-item"><a class="post-list-link" href="../../07/程序警言/">程序警言</a></li><li class="post-list-item"><a class="post-list-link" href="../../07/UniRx-学习-2-存储层次数据/">UniRx-学习[2]--存储层次数据</a></li><li class="post-list-item"><a class="post-list-link" href="">UniRx 学习</a></li><li class="post-list-item"><a class="post-list-link" href="../../04/顺利拿到一坑/">顺利拿到一坑</a></li><li class="post-list-item"><a class="post-list-link" href="../../04/翻译-game-data-and-Entitas/">[翻译]game,data and Entitas</a></li><li class="post-list-item"><a class="post-list-link" href="../../../10/14/makeMap/">地图测试</a></li><li class="post-list-item"><a class="post-list-link" href="../../../10/09/art-style/">美术风格</a></li><li class="post-list-item"><a class="post-list-link" href="../../../10/07/UX/">UX框架</a></li><li class="post-list-item"><a class="post-list-link" href="../../../10/05/githug/">githug</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://marklodato.github.io/visual-git-guide/index-zh-cn.html" title="图解Git" target="_blank">图解Git</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="../../../../." rel="nofollow">DungeonsGame.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="../../../../js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="../../../../js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="../../../../css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="../../../../js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="../../../../js/smartresize.js?v=0.0.0"></script></div></body></html>